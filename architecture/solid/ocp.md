# Принцип открытости-закрытости
Принцип открытости-закрытости `(Open-Closed Principle, OCP)` - модули должны быть `открыты для расширения`, но `закрыты для изменения`.

`Основная цель принципа — помочь разработать проект, устойчивый к изменениям, срок жизни которых превышает срок существования первой версии проекта.`

## Модули, которые удовлетворяют OCP:

- открыты для расширения — их функциональность может быть дополнена с помощью других модулей, если изменятся требования;
- закрыты для изменения — расширение функциональности модуля не должно приводить к изменениям в модулях, которые его используют.

## Принцип открытости-закрытости:

- заставляет проектировать модули так, чтобы они` делали только одну вещь` и делали её хорошо;
- побуждает `связывать сущности через абстракции` (а не реализацию) там, `где могут поменяться бизнес-требования`;
- обращает внимание проектировщиков на места стыка и взаимодействие сущностей;
- позволяет` сократить количество кода, который необходимо менять при изменении бизнес-требований`;
- делает` внесение изменений безопасным и относительно дешёвым.`

##  Материалы к разделу

https://ru.wikipedia.org/wiki/Принцип_открытости/закрытости
https://courses.cs.duke.edu//fall07/cps108/papers/ocp.pdf

## Нарушение OCP и конкретика
Ключ к пониманию OCP — применение абстракций в местах стыка модулей.

## Ограничения и подводные камни

### Система не может быть закрыта на 100%

Всегда есть изменения, которые невозможно внести, не изменив код какого-то модуля, поэтому при проектировании важен стратегический подход. Необходимо определить, от каких именно изменений и какие именно модули вы хотите закрыть.

Цель подхода в том, чтобы не создавать абстракции на пустом месте. Один из критериев хорошего дизайна — простота, поэтому использовать OCP следует всегда с оглядкой на то, насколько система получится простой в итоге.

Добавление функциональности менее рискованно, чем изменение существующей, но взамен мы рискуем увеличить количество сущностей. Бесконтрольное и бездумное следование OCP может приводить к ситуациям, когда интерфейсов станет слишком много, а функциональность — станет раздробленной.